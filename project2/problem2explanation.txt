I decided to tackle the second problem in Project 2 because it seemed more interesting and easier to understand than the first.

The structure of my program, from a birds-eye view, is a set of threads that function on a pseudo-state machine. The reason I say this is there is never really a reason to enter / change states "out of order," so it just runs top-to-bottom through the 6 pre-defined states from the instructions: IDLE, AWAIT_TAKEOFF, TAKEOFF, FLYING, AWAIT_LANDING, and LANDING. Each thread represents one of the 45 planes in the system (30 small, 15 large). I began this project by creating elaborate data structures that would be able to reference each other through pointers, but a lot of that got scrapped by the end because it turned out to be useless. In the end, I'm pretty happy with the solution that I am submitting because a LOT of time went into troubleshooting and being certain that no collisions were happening (if you experience them, I will be devastated). In addition, I went through many different versions of my AWAIT_TAKEOFF state because I continued to encounter deadlock.

So, here’s my solution to it:
A little background first. Each of the regions on the map is its own struct with an ID number and a semaphore associated with its “occupation.” What I found out through debugging my original versions was planes (threads) that had opened a lock on one of the two (or three) semaphores would then get stuck because another plane (thread) had already claimed that region as its first, therefore not allowing either of them or the rest of the planes (threads) that needed that region to progress. My solution was a “repetitive lock check.” Here’s how it works: Instead of using sem_wait() to open / wait for a lock, I use sem_trywait() and save the output (0 if the semaphore has been pulled down correctly, -1 otherwise). I then check the two (or three) outputs to see if they’re all equal to 0. If so, all the regions for takeoff are available and the plane (thread) can advance to the next state. However, if one or more of the regions were occupied when checking (i.e. output was -1), then the plane (thread) will release the hold on the locks is has to 1) give other planes (threads) a chance to grab those regions for themselves and 2) allow time to pass to, hopefully, gain access to the region(s) that it could not. This loop will continue indefinitely until the plane (thread) is able to have access to all the regions it needs to take off. This exact same method is used when the plane (thread) is in the AWAIT_LANDING state and it needs to, again, secure two (three) regions for a safe landing. Do I think this solution is the most efficient: no. However, I am proud of the fact that I came to it on my own after relentless testing, trial, and error.

The rest of the program is fairly straightforward, making use of a lot of random int generation and switches to determine a random runway (regions) for the planes (threads) to use for both takeoff and landing.
